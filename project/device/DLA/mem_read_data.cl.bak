// Fetch Data from Global Memory
__kernel
__attribute__((task))
__attribute__((max_global_work_dim(0)))
void memReadData(
			// Params Ports
			uchar  data_dim1,
			uchar  data_dim2,
			ushort data_dim1xdim2,
			uchar  weight_dim1,
			uchar  weight_dim2,
			ushort weight_dim3,
			ushort weight_dim4_div_lane, // avoid generating divider
			uchar  weight_dim1x2,
			uint   weight_dim1x2x3,
			uchar  conv_x,
			//uchar  conv_y,           // not used in this version
			uchar  stride,
			uchar  padding,
			uchar  split,
			uchar  group_num_x,
			uchar  group_num_y,
			uchar  group_rem_size_x,
			//uchar  group_rem_size_y, // not used in this version
			uint   group_rem_size_xyz,
			uchar  win_size_x,
			uchar  win_size_y,
			uint   win_size_xyz,  
			// Data Ports
			__global lane_data    *restrict bottom,
			__global channel_vec  *restrict weights,
			__global channel_scal *restrict bias)

{


	// Input Data, Weights and Bias
	lane_data     data_vec;
	channel_vec   data_ch_vec;
		
	// virtual loop counters
	ushort gp_num_x, gp_num_y, out_idx_z;
	ushort gp_num_x_winbuf, gp_num_y_winbuf, out_idx_z_winbuf;
	uchar  win_itm_x, win_itm_y;
	ushort win_itm_z;
	uchar flag; // ping-pong flag

	// Ping-pong buffer
	__local lane_data    win_buffer[2][WIN_BUF_SIZE]; // working sequence 0->1->0->1 ...
	
	// Initialize the winbuf with the data in the first iteration of the group looping (as gp_num_x_winbuf=0, gp_num_y_winbuf=0)
	
	for(unsigned short win_itm_z=0; win_itm_z<weight_dim3/VEC_SIZE; win_itm_z++){
		for(unsigned char  win_itm_y=0; win_itm_y<win_size_y; win_itm_y++){
			for(unsigned char  win_itm_x=0; win_itm_x<win_size_x; win_itm_x++){
				ushort feature_idx_dim1, feature_idx_dim2;
				ushort feature_idx_dim3;
				lane_data data_vec;

				feature_idx_dim1 = win_itm_x;
				feature_idx_dim2 = win_itm_y;
				feature_idx_dim3 = win_itm_z;
	
				if((feature_idx_dim1>=padding && feature_idx_dim1<data_dim1+padding) && (feature_idx_dim2>=padding && feature_idx_dim2<data_dim2+padding)){
			
					data_vec = bottom[feature_idx_dim3*data_dim1xdim2 + (feature_idx_dim2-padding)*data_dim1 + (feature_idx_dim1-padding)];
				}
				else{
					#pragma unroll
					for(unsigned char vv=0; vv<VEC_SIZE; vv++){
						data_vec.data[vv] = CZERO;
					}
				}
			
				win_buffer[0][win_itm_z*win_size_y*win_size_x + win_itm_y*win_size_x + win_itm_x] = data_vec;
			}
		}
	}

	

	if(group_num_x==1)
		gp_num_x_winbuf = 0; // there is only one group for FC mode when batch=1
	else
		gp_num_x_winbuf = 1; // loop start from the second group
	gp_num_y_winbuf = 0;
	out_idx_z_winbuf = 0;
	
	// reset global group virtual loop counters
	gp_num_x = 0;
	gp_num_y = 0;
	out_idx_z = 0;

	// #pragma ivdep array(win_buffer)
	for(unsigned int out_idx_xyz=0; out_idx_xyz<(weight_dim4_div_lane*group_num_y*group_num_x); out_idx_xyz++){
		ushort        data_offset = 0; // assuming the 1st layer is not in split
		
		uchar  	      output_idx_dim1, output_idx_dim2;
		ushort	      output_idx_dim3;
		uchar  	      gp_item_idx_x;
		uchar  	      win_itm_x, win_itm_y;
		ushort 	      win_itm_z;
		uint   item_loop_bound;

		// special case when split==1, the output feature maps depend on only half the input feature maps
		if(split==0)
			data_offset = 0;
		else if(out_idx_z_winbuf<(weight_dim4_div_lane>>1)) // the lower half of the output feature maps depend on the lower half of the input
			data_offset = 0;
		else
			data_offset = weight_dim3/VEC_SIZE;	// the upper half of the output feature maps depend on the upper half of the input
	
		flag = out_idx_xyz & 0x01; //ping-pong flag
				
		// reset output loop counters
		output_idx_dim1 = 0;
		output_idx_dim2 = 0;
		output_idx_dim3 = 0;
		// reset in-group item counters 
		gp_item_idx_x = 0;
				
		// reset input winbuffer loop counters
		win_itm_x = 0;
		win_itm_y = 0;
		win_itm_z = 0;
				
				
		if(gp_num_x==group_num_x-1)
			item_loop_bound = win_size_x>=group_rem_size_x?(win_size_xyz/VEC_SIZE):(group_rem_size_xyz/VEC_SIZE);
		else{
			item_loop_bound = (weight_dim1x2x3*CONV_GP_SIZE_Y*CONV_GP_SIZE_X/VEC_SIZE);
		}

		#pragma ivdep array(win_buffer)
		for(unsigned int win_itm_xyz = 0; win_itm_xyz < item_loop_bound; win_itm_xyz++) {
			ushort feature_idx_dim1, feature_idx_dim2;
			ushort feature_idx_dim3;
			// Winbuffer loading operations
			if(win_itm_z<weight_dim3/VEC_SIZE){
				
				lane_data data_vec;
				feature_idx_dim1 = win_itm_x+gp_num_x_winbuf*CONV_GP_SIZE_X*stride;
				feature_idx_dim2 = win_itm_y+gp_num_y_winbuf*CONV_GP_SIZE_Y*stride;
				feature_idx_dim3 = win_itm_z;

				if((feature_idx_dim1>=padding && feature_idx_dim1<data_dim1+padding) && (feature_idx_dim2>=padding && feature_idx_dim2<data_dim2+padding)){
								
					data_vec = bottom[data_offset*data_dim1xdim2 + feature_idx_dim3*data_dim1xdim2 + (feature_idx_dim2-padding)*data_dim1 + (feature_idx_dim1-padding)];
				}
				else{ // for padding (feature_idx<padding or data_dim+padding<=feature_idx<data_dim+2*padding)
					#pragma unroll
					for(unsigned char vv=0; vv<VEC_SIZE; vv++){
						data_vec.data[vv] = CZERO;
					}
				}
				win_buffer[(~flag)&0x01][win_itm_z*win_size_y*win_size_x + win_itm_y*win_size_x + win_itm_x] = data_vec;	

				// used as loop counters
				if((win_itm_z==weight_dim3/VEC_SIZE-1) && (win_itm_y==win_size_y-1) && (win_itm_x==win_size_x-1))
					win_itm_z = 0;
				else if((win_itm_y==win_size_y-1) && (win_itm_x==win_size_x-1))
					win_itm_z++;

				if((win_itm_y==win_size_y-1) && (win_itm_x==win_size_x-1))
					win_itm_y = 0;
				else if(win_itm_x==win_size_x-1)
					win_itm_y++;
								
				if(win_itm_x==win_size_x-1)
					win_itm_x = 0;
				else
					win_itm_x++;
									
			}
							
			// Load weight into weight buffer
							
			// In this version, grouping is only performed in row (x) direction
			if(gp_num_x*CONV_GP_SIZE_X+gp_item_idx_x<conv_x){
				lane_data data_vec;
				channel_vec   data_ch_vec;
				// data
				data_vec = win_buffer[flag][output_idx_dim3*win_size_y*win_size_x + output_idx_dim2*win_size_x + (output_idx_dim1+gp_item_idx_x*stride)];

				//#pragma unroll
				//for(unsigned char ll=0; ll<LANE_NUM; ll++){
				//	data_ch_vec.lane[ll] = data_vec;
				//}
				write_channel_intel(data_ch, data_vec);



			}
			// used as output loop counters
			if((output_idx_dim3==weight_dim3/VEC_SIZE-1) && (output_idx_dim2==weight_dim2-1) && (output_idx_dim1==weight_dim1-1)){
				output_idx_dim3 = 0;
				gp_item_idx_x++;
			}
			else if((output_idx_dim2==weight_dim2-1)&& (output_idx_dim1==weight_dim1-1))
				output_idx_dim3++;
							
			if((output_idx_dim2==weight_dim2-1) && (output_idx_dim1==weight_dim1-1))
				output_idx_dim2 = 0;
			else if(output_idx_dim1==weight_dim1-1)
				output_idx_dim2++;
	                
			if(output_idx_dim1==weight_dim1-1)
				output_idx_dim1 = 0;
			else
				output_idx_dim1++;

		}

		// used as virtual group loop counters for winbuf loading operations
		if((out_idx_z_winbuf==weight_dim4_div_lane-1) && (gp_num_y_winbuf==group_num_y-1) && (gp_num_x_winbuf==group_num_x-1))
			out_idx_z_winbuf = 0;
		else if((gp_num_y_winbuf==group_num_y-1) && (gp_num_x_winbuf==group_num_x-1))
			out_idx_z_winbuf++;	

		if((gp_num_y_winbuf==group_num_y-1) && (gp_num_x_winbuf==group_num_x-1))
			gp_num_y_winbuf = 0;
		else if(gp_num_x_winbuf==group_num_x-1)
			gp_num_y_winbuf++;	

		if(gp_num_x_winbuf==group_num_x-1)
			gp_num_x_winbuf = 0;
		else
			gp_num_x_winbuf++;
		
		// used as virtual group loop counters
		if((out_idx_z==weight_dim4_div_lane-1) && (gp_num_y==group_num_y-1) && (gp_num_x==group_num_x-1))
			out_idx_z = 0;
		else if((gp_num_y==group_num_y-1) && (gp_num_x==group_num_x-1))
			out_idx_z++;	
        
		if((gp_num_y==group_num_y-1) && (gp_num_x==group_num_x-1))
			gp_num_y = 0;
		else if(gp_num_x==group_num_x-1)
			gp_num_y++;
        
		if(gp_num_x==group_num_x-1)
			gp_num_x = 0;
		else
			gp_num_x++;

	}
	
	//printf("Kernel 0 lanched !!!\n");
}
